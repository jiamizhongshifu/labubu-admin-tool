下面给出一个思路与示例，展示如何在 iOS 上使用 SwiftUI＋Metal＋陀螺仪（CoreMotion）来实现类似视频里“随设备倾斜而产生 3D 视差/光照变化”按钮效果。

---

## 1. 整体架构

1. **CoreMotion**：采集设备的实时姿态（pitch/roll/yaw）。
2. **Metal（MTKView）**：做真正的 GPU 渲染，通过「顶点着色器」把按钮 Mesh 随设备姿态做 3D 变换/光照计算。
3. **SwiftUI**：用 `UIViewRepresentable` 把 MTKView 嵌入 SwiftUI，或者直接将 Metal 渲染结果作为纹理贴到 SwiftUI 的 `Canvas`、`Image` 上。

---

## 2. 核心模块拆分

```
┌───────────────────┐       ┌──────────┐
│   MotionManager   │──────▶│   Metal   │─┐
│ (CoreMotion CM)   │       │ Renderer │ │ 更新 uniform
└───────────────────┘       └──────────┘ │
      ▲                                   │
      │ SwiftUI 绑定                       ▼
┌───────────────────┐       ┌──────────┐  每帧渲染
│  SwiftUI Content  │◀──────│ MTKView   │◀─► GPU
└───────────────────┘       └──────────┘
```

---

## 3. 关键代码示例

### 3.1 MotionManager：实时获取姿态

```swift
import CoreMotion
import Combine

class MotionManager: ObservableObject {
    private let motion = CMMotionManager()
    @Published var attitude: CMQuaternion = .init(x: 0, y: 0, z: 0, w: 1)
    
    init() {
        motion.deviceMotionUpdateInterval = 1/60
        motion.startDeviceMotionUpdates(to: .main) { [weak self] data, _ in
            guard let q = data?.attitude.quaternion else { return }
            self?.attitude = q
        }
    }
}
```

### 3.2 MetalRenderer：设置 MTKView & 着色器

```swift
import MetalKit

class MetalRenderer: NSObject, MTKViewDelegate {
    let device: MTLDevice
    let queue: MTLCommandQueue
    var pipeline: MTLRenderPipelineState
    var uniformBuffer: MTLBuffer
    
    // 从 MotionManager 接收的四元数，将转成 float3 euler
    var attitude: CMQuaternion = .init(x:0,y:0,z:0,w:1)
    
    init(mtkView: MTKView) {
        device = MTLCreateSystemDefaultDevice()!
        queue = device.makeCommandQueue()!
        // 编译 .metal 文件中 vertex_main + fragment_main
        let lib = device.makeDefaultLibrary()!
        let desc = MTLRenderPipelineDescriptor()
        desc.vertexFunction = lib.makeFunction(name: "vertex_main")
        desc.fragmentFunction = lib.makeFunction(name: "fragment_main")
        desc.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat
        pipeline = try! device.makeRenderPipelineState(descriptor: desc)
        
        // 分配 uniform buffer (存放 4x4 MVP 矩阵、法线矩阵等)
        uniformBuffer = device.makeBuffer(length: MemoryLayout<matrix_float4x4>.stride*2, options: [])
        
        super.init()
        mtkView.device = device
        mtkView.delegate = self
    }
    
    func draw(in view: MTKView) {
        guard let drawable = view.currentDrawable,
              let pass = view.currentRenderPassDescriptor else { return }
        // 1. 把 attitude 转成 MVP 矩阵
        let mvp = makeMVP(from: attitude, aspect: Float(view.drawableSize.x/view.drawableSize.y))
        // 2. 更新 Buffer
        memcpy(uniformBuffer.contents(), &mvp, MemoryLayout<matrix_float4x4>.stride)
        
        // 3. 编码渲染命令
        let cmd = queue.makeCommandBuffer()!
        let encoder = cmd.makeRenderCommandEncoder(descriptor: pass)!
        encoder.setRenderPipelineState(pipeline)
        encoder.setVertexBuffer(uniformBuffer, offset: 0, index: 1)
        // 假设顶点 buffer 已经创建，并绑定到 index 0
        encoder.drawPrimitives(type: .triangle, vertexStart: 0, vertexCount: 6)
        encoder.endEncoding()
        cmd.present(drawable)
        cmd.commit()
    }
    
    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) { }
    
    private func makeMVP(from q: CMQuaternion, aspect: Float) -> matrix_float4x4 {
        // 四元数 → 旋转矩阵
        let R = simd_quatf(ix: Float(q.x), iy: Float(q.y), iz: Float(q.z), r: Float(q.w)).matrix
        // 投影矩阵
        let P = matrix_perspective_left_hand(fovyRadians: .pi/3, aspect: aspect, nearZ: 0.1, farZ: 100)
        // 视图矩阵（相机在 z 轴后退 2 单位）
        let V = matrix4x4_translation(0, 0, -2)
        return P * V * R
    }
}
```

> **Shader（button.metal）**
>
> ```metal
> #include <metal_stdlib>
> using namespace metal;
> struct Vertex {
>   float3 pos [[attribute(0)]];
>   float2 uv  [[attribute(1)]];
> };
> struct Uniforms {
>   float4x4 mvp;
> };
> vertex float4 vertex_main(Vertex in [[stage_in]],
>                           constant Uniforms &u [[buffer(1)]]) {
>   return u.mvp * float4(in.pos, 1.0);
> }
> fragment float4 fragment_main() {
>   // 简单白色按钮，可扩展为纹理采样、法线光照等
>   return float4(1.0);
> }
> ```

### 3.3 SwiftUI 包装

```swift
import SwiftUI
import MetalKit

struct MetalButtonView: UIViewRepresentable {
    @ObservedObject var motion: MotionManager
    func makeUIView(context: Context) -> MTKView {
        let view = MTKView()
        let renderer = MetalRenderer(mtkView: view)
        context.coordinator.renderer = renderer
        view.preferredFramesPerSecond = 60
        return view
    }
    func updateUIView(_ uiView: MTKView, context: Context) {
        context.coordinator.renderer?.attitude = motion.attitude
    }
    func makeCoordinator() -> Coordinator { Coordinator() }
    class Coordinator {
        var renderer: MetalRenderer?
    }
}

struct ContentView: View {
    @StateObject var motion = MotionManager()
    var body: some View {
        ZStack {
            Color(.systemBackground).edgesIgnoringSafeArea(.all)
            MetalButtonView(motion: motion)
                .frame(width: 200, height: 60)
                .cornerRadius(12)
                .shadow(radius: 5)
        }
    }
}
```

---

## 4. 可拓展点

* **光照**：在 fragment shader 内做 Blinn–Phong 光照，结合陀螺仪获取的方向，让按钮表面高光随设备倾斜动态移动。
* **纹理**：顶点着色器负责模型变形／3D 视差；片元着色器做按钮皮肤、法线贴图。
* **动画**：可结合 SwiftUI 动画（长按、点击态），在 Metal 渲染之上叠加变形或过渡。
* **性能**：只在确实倾斜时更新 uniforms，可用 `allowsNextDrawableTimeout`、`preferredFrameRate` 优化功耗。

---

以上就是在 SwiftUI 项目中，结合 Metal 和 CoreMotion，实现「随陀螺仪动态变换」按钮效果的完整思路与示例。你可以根据具体视频效果，调整顶点数据、shader 算法，以及 UI 封装的方式。祝开发顺利！
