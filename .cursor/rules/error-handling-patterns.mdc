---
description:
globs:
alwaysApply: false
---
# Error Handling Patterns

## Core Error Types

### AI Recognition Errors
Defined in [LabubuAIRecognitionService.swift](mdc:jitata/Services/LabubuAIRecognitionService.swift):

```swift
enum AIRecognitionError: LocalizedError {
    case apiConfigurationMissing
    case rateLimited
    case insufficientCredits
    case timeout
    case serverError(Int)
    case networkError(Error)
    case invalidResponse
    case jsonParsingFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .apiConfigurationMissing:
            return "APIé…ç½®ç¼ºå¤±ï¼Œè¯·æ£€æŸ¥ç¯å¢ƒå˜é‡è®¾ç½®"
        case .rateLimited:
            return "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•"
        case .insufficientCredits:
            return "APIé¢åº¦ä¸è¶³ï¼Œè¯·è”ç³»ç®¡ç†å‘˜"
        case .timeout:
            return "è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥"
        case .serverError(let code):
            return "æœåŠ¡å™¨é”™è¯¯ (\(code))ï¼Œè¯·ç¨åé‡è¯•"
        case .networkError:
            return "ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®"
        case .invalidResponse:
            return "æœåŠ¡å™¨å“åº”æ ¼å¼é”™è¯¯"
        case .jsonParsingFailed(let details):
            return "æ•°æ®è§£æå¤±è´¥: \(details)"
        }
    }
}
```

## Error Classification Strategy

### HTTP Status Code Mapping
```swift
func classifyError(statusCode: Int) -> AIRecognitionError {
    switch statusCode {
    case 401:
        return .apiConfigurationMissing
    case 429:
        return .rateLimited
    case 402, 403:
        return .insufficientCredits
    case 408, 504:
        return .timeout
    case 500...599:
        return .serverError(statusCode)
    default:
        return .invalidResponse
    }
}
```

### Network Error Handling
```swift
func handleNetworkError(_ error: Error) -> AIRecognitionError {
    if let urlError = error as? URLError {
        switch urlError.code {
        case .timedOut:
            return .timeout
        case .notConnectedToInternet, .networkConnectionLost:
            return .networkError(error)
        default:
            return .networkError(error)
        }
    }
    return .networkError(error)
}
```

## JSON Parsing Error Recovery

### Multi-Layer Parsing Strategy
Implement progressive fallback parsing as shown in the AI service:

```swift
func parseAIResponse(_ content: String) throws -> AIRecognitionResult {
    var lastError: Error?
    
    // Method 1: Extract ```json code blocks
    if let result = try? parseJSONCodeBlock(content) {
        return result
    }
    
    // Method 2: Extract regular code blocks
    if let result = try? parseCodeBlock(content) {
        return result
    }
    
    // Method 3: Find JSON objects with regex
    if let result = try? parseJSONWithRegex(content) {
        return result
    }
    
    // Method 4: Use raw content as fallback
    if let result = try? parseRawJSON(content) {
        return result
    }
    
    throw AIRecognitionError.jsonParsingFailed("æ‰€æœ‰è§£ææ–¹æ³•éƒ½å¤±è´¥")
}
```

### Unicode Character Cleaning
Always clean problematic Unicode characters before JSON parsing:

```swift
func cleanJSONString(_ input: String) -> String {
    return input
        .replacingOccurrences(of: "\u{201C}", with: "\"") // Left double quote
        .replacingOccurrences(of: "\u{201D}", with: "\"") // Right double quote
        .replacingOccurrences(of: "\u{2018}", with: "'")  // Left single quote
        .replacingOccurrences(of: "\u{2019}", with: "'")  // Right single quote
        .trimmingCharacters(in: .whitespacesAndNewlines)
}
```

## UI Error Presentation

### User-Friendly Error Messages
Convert technical errors to user-friendly messages:

```swift
func userFriendlyErrorMessage(for error: Error) -> String {
    if let aiError = error as? AIRecognitionError {
        return aiError.localizedDescription
    }
    
    switch error {
    case is URLError:
        return "ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®"
    case is DecodingError:
        return "æ•°æ®æ ¼å¼é”™è¯¯ï¼Œè¯·é‡è¯•"
    default:
        return "å‘ç”ŸæœªçŸ¥é”™è¯¯ï¼Œè¯·é‡è¯•"
    }
}
```

### Error State Management in Views
```swift
@State private var errorMessage: String?
@State private var showingError = false

// Error handling in async operations
Task {
    do {
        let result = try await performOperation()
        // Handle success
    } catch {
        await MainActor.run {
            self.errorMessage = userFriendlyErrorMessage(for: error)
            self.showingError = true
        }
    }
}

// Error presentation
.alert("é”™è¯¯", isPresented: $showingError) {
    Button("ç¡®å®š") { }
} message: {
    Text(errorMessage ?? "æœªçŸ¥é”™è¯¯")
}
```

## Logging and Debugging

### Structured Logging Pattern
```swift
func logError(_ error: Error, context: String, additionalInfo: [String: Any] = [:]) {
    print("âŒ [\(context)] é”™è¯¯: \(error.localizedDescription)")
    
    if !additionalInfo.isEmpty {
        print("ğŸ“‹ [\(context)] é™„åŠ ä¿¡æ¯: \(additionalInfo)")
    }
    
    #if DEBUG
    print("ğŸ” [\(context)] è¯¦ç»†é”™è¯¯: \(error)")
    #endif
}
```

### Performance Impact Logging
```swift
func logPerformanceImpact(operation: String, duration: TimeInterval, success: Bool) {
    let status = success ? "âœ…" : "âŒ"
    print("\(status) [\(operation)] è€—æ—¶: \(String(format: "%.2f", duration))ç§’")
}
```

## Retry Strategies

### Exponential Backoff for Network Requests
```swift
func performWithRetry<T>(
    maxAttempts: Int = 3,
    baseDelay: TimeInterval = 1.0,
    operation: @escaping () async throws -> T
) async throws -> T {
    var lastError: Error?
    
    for attempt in 1...maxAttempts {
        do {
            return try await operation()
        } catch {
            lastError = error
            
            if attempt < maxAttempts {
                let delay = baseDelay * pow(2.0, Double(attempt - 1))
                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            }
        }
    }
    
    throw lastError ?? NSError(domain: "RetryError", code: -1)
}
```

## Error Recovery Patterns

### Graceful Degradation
```swift
func loadModelImages(modelId: String) async -> [String] {
    do {
        // Try primary data source
        return try await primaryImageService.fetchImages(modelId: modelId)
    } catch {
        print("âš ï¸ [å›¾ç‰‡åŠ è½½] ä¸»è¦æ•°æ®æºå¤±è´¥ï¼Œå°è¯•å¤‡ç”¨æ–¹æ¡ˆ")
        
        do {
            // Try fallback data source
            return try await fallbackImageService.fetchImages(modelId: modelId)
        } catch {
            print("âŒ [å›¾ç‰‡åŠ è½½] æ‰€æœ‰æ•°æ®æºéƒ½å¤±è´¥ï¼Œè¿”å›é»˜è®¤å›¾ç‰‡")
            return ["default_placeholder_url"]
        }
    }
}
```

### Cache-First Error Recovery
```swift
func loadWithCacheRecovery<T>(
    cacheKey: String,
    networkOperation: () async throws -> T,
    cacheOperation: () -> T?
) async -> T? {
    do {
        let result = try await networkOperation()
        // Cache successful result
        return result
    } catch {
        print("âš ï¸ [ç¼“å­˜æ¢å¤] ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨ç¼“å­˜")
        return cacheOperation()
    }
}
```
