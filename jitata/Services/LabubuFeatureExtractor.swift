//
//  LabubuFeatureExtractor.swift
//  jitata
//
//  Created by AI Assistant on 2025/6/7.
//

import Foundation
import UIKit
import Vision
import CoreImage
import Accelerate

/// LabubuÁâπÂæÅÊèêÂèñÂô®
/// ‰ªéÂõæÁâá‰∏≠ÊèêÂèñÈ¢úËâ≤„ÄÅÂΩ¢Áä∂„ÄÅÁ∫πÁêÜÁ≠âËßÜËßâÁâπÂæÅ
class LabubuFeatureExtractor: ObservableObject {
    
    static let shared = LabubuFeatureExtractor()
    
    private let context = CIContext()
    
    init() {}
    
    // MARK: - ‰∏ªË¶ÅÊñπÊ≥ï
    
    /// ‰ªéÂõæÁâá‰∏≠ÊèêÂèñÂÆåÊï¥ÁöÑËßÜËßâÁâπÂæÅ
    /// - Parameter image: ËæìÂÖ•ÂõæÁâá
    /// - Returns: ÊèêÂèñÁöÑËßÜËßâÁâπÂæÅ
    func extractFeatures(from image: UIImage) async throws -> VisualFeatures {
        print("üîç ÂºÄÂßãÊèêÂèñÂõæÂÉèÁâπÂæÅ...")
        
        guard let cgImage = image.cgImage else {
            throw FeatureExtractionError.invalidImage
        }
        
        // Âπ∂Ë°åÊèêÂèñ‰∏çÂêåÁ±ªÂûãÁöÑÁâπÂæÅ
        async let colorFeatures = extractColorFeatures(cgImage)
        async let shapeFeatures = extractShapeFeatures(cgImage)
        async let textureFeatures = extractTextureFeatures(cgImage)
        async let featureVector = extractDeepFeatures(cgImage)
        
        do {
            let colors = try await colorFeatures
            let shape = try await shapeFeatures
            let texture = try await textureFeatures
            let vector = try await featureVector
            
            let features = VisualFeatures(
                primaryColors: colors.dominantColors.map { 
                    ColorFeature(
                        color: $0, 
                        percentage: 1.0 / Double(colors.dominantColors.count),
                        region: .body
                    ) 
                },
                colorDistribution: colors.distribution,
                shapeDescriptor: shape,
                contourPoints: shape.keyPoints,
                textureFeatures: texture,
                specialMarks: extractSpecialMarks(colors.dominantColors, shape).map { 
                    SpecialMark(
                        type: .pattern, 
                        location: CGPoint(x: 0.5, y: 0.5),
                        size: CGSize(width: 0.1, height: 0.1),
                        description: $0
                    ) 
                },
                featureVector: vector
            )
            
            print("‚úÖ ÁâπÂæÅÊèêÂèñÂÆåÊàê")
            return features
            
        } catch {
            print("‚ùå ÁâπÂæÅÊèêÂèñÂ§±Ë¥•: \(error)")
            throw FeatureExtractionError.extractionFailed
        }
    }
    
    // MARK: - È¢úËâ≤ÁâπÂæÅÊèêÂèñ
    
    private func extractColorFeatures(_ cgImage: CGImage) async throws -> ColorFeatures {
        return try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                let colorAnalyzer = ColorAnalyzer()
                let result = colorAnalyzer.analyzeColors(cgImage)
                continuation.resume(returning: result)
            }
        }
    }
    
    // MARK: - ÂΩ¢Áä∂ÁâπÂæÅÊèêÂèñ
    
    private func extractShapeFeatures(_ cgImage: CGImage) async throws -> ShapeDescriptor {
        return try await withCheckedThrowingContinuation { continuation in
            let request = VNDetectContoursRequest { request, error in
                if let error = error {
                    continuation.resume(throwing: error)
                    return
                }
                
                guard let observations = request.results as? [VNContoursObservation],
                      let firstContour = observations.first else {
                    // Â¶ÇÊûúÊ≤°ÊúâÊ£ÄÊµãÂà∞ËΩÆÂªìÔºåËøîÂõûÈªòËÆ§ÂÄº
                    let defaultShape = ShapeDescriptor(
                        aspectRatio: 1.0,
                        roundness: 0.8,
                        symmetry: 0.7,
                        complexity: 0.5,
                        keyPoints: []
                    )
                    continuation.resume(returning: defaultShape)
                    return
                }
                
                // ÂàÜÊûêËΩÆÂªìÁâπÂæÅ
                let shapeAnalyzer = ShapeAnalyzer()
                let descriptor = shapeAnalyzer.analyzeContour(firstContour)
                continuation.resume(returning: descriptor)
            }
            
            request.contrastAdjustment = 1.5
            request.detectsDarkOnLight = true
            
            let handler = VNImageRequestHandler(cgImage: cgImage)
            
            do {
                try handler.perform([request])
            } catch {
                continuation.resume(throwing: error)
            }
        }
    }
    
    // MARK: - Á∫πÁêÜÁâπÂæÅÊèêÂèñ
    
    private func extractTextureFeatures(_ cgImage: CGImage) async throws -> LabubuTextureFeatures {
        return try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                let textureAnalyzer = TextureAnalyzer()
                let features = textureAnalyzer.analyzeTexture(cgImage)
                continuation.resume(returning: features)
            }
        }
    }
    
    // MARK: - Ê∑±Â∫¶ÁâπÂæÅÊèêÂèñ
    
    private func extractDeepFeatures(_ cgImage: CGImage) async throws -> [Float] {
        // ‰ΩøÁî®È¢ÑËÆ≠ÁªÉÁöÑÁâπÂæÅÊèêÂèñÊ®°Âûã
        return try await withCheckedThrowingContinuation { continuation in
            // ÁÆÄÂåñÁâàÊú¨Ôºö‰ΩøÁî®ÂõæÂÉèÁöÑÁªüËÆ°ÁâπÂæÅ‰Ωú‰∏∫ÁâπÂæÅÂêëÈáè
            DispatchQueue.global(qos: .userInitiated).async {
                let featureExtractor = DeepFeatureExtractor()
                let features = featureExtractor.extractStatisticalFeatures(cgImage)
                continuation.resume(returning: features)
            }
        }
    }
    
    // MARK: - ÁâπÊÆäÊ†áËÆ∞ËØÜÂà´
    
    private func extractSpecialMarks(_ colors: [String], _ shape: ShapeDescriptor) -> [String] {
        var marks: [String] = []
        
        // Âü∫‰∫éÈ¢úËâ≤ÁöÑÊ†áËÆ∞
        for colorHex in colors {
            if let color = UIColor(hex: colorHex) {
                if isCloseToColor(color, target: UIColor.systemPink) {
                    marks.append("Á≤âËâ≤‰∏ª‰Ωì")
                } else if isCloseToColor(color, target: UIColor.systemBlue) {
                    marks.append("ËìùËâ≤‰∏ª‰Ωì")
                } else if isCloseToColor(color, target: UIColor.systemYellow) {
                    marks.append("ÈªÑËâ≤‰∏ª‰Ωì")
                } else if isCloseToColor(color, target: UIColor.systemRed) {
                    marks.append("Á∫¢Ëâ≤Ë£ÖÈ•∞")
                }
            }
        }
        
        // Âü∫‰∫éÂΩ¢Áä∂ÁöÑÊ†áËÆ∞
        if shape.roundness > 0.8 {
            marks.append("ÂúÜÊ∂¶ÈÄ†Âûã")
        }
        
        if shape.symmetry > 0.7 {
            marks.append("ÂØπÁß∞ËÆæËÆ°")
        }
        
        return marks
    }
    
    // MARK: - ËæÖÂä©ÊñπÊ≥ï
    
    private func isCloseToColor(_ color1: UIColor, target color2: UIColor) -> Bool {
        var r1: CGFloat = 0, g1: CGFloat = 0, b1: CGFloat = 0, a1: CGFloat = 0
        var r2: CGFloat = 0, g2: CGFloat = 0, b2: CGFloat = 0, a2: CGFloat = 0
        
        color1.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color2.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)
        
        let distance = sqrt(pow(r1 - r2, 2) + pow(g1 - g2, 2) + pow(b1 - b2, 2))
        return distance < 0.3 // ÈòàÂÄºÂèØË∞ÉÊï¥
    }
    
    /// ÊèêÂèñËßÜËßâÁâπÂæÅÔºàÂÖºÂÆπÊÄßÊñπÊ≥ïÔºâ
    func extractVisualFeatures(from image: UIImage) async throws -> VisualFeatures {
        return try await extractFeatures(from: image)
    }
}

// MARK: - ËæÖÂä©Á±ª

/// È¢úËâ≤ÂàÜÊûêÂô®
private class ColorAnalyzer {
    func analyzeColors(_ cgImage: CGImage) -> ColorFeatures {
        let ciImage = CIImage(cgImage: cgImage)
        
        // ÊèêÂèñ‰∏ªË¶ÅÈ¢úËâ≤
        let dominantColors = extractDominantColors(ciImage)
        
        // ËÆ°ÁÆóÈ¢úËâ≤ÂàÜÂ∏É
        let distribution = calculateColorDistribution(ciImage)
        
        return ColorFeatures(dominantColors: dominantColors, distribution: distribution)
    }
    
    private func extractDominantColors(_ ciImage: CIImage) -> [String] {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöËøîÂõû‰∏Ä‰∫õÂ∏∏ËßÅÁöÑLabubuÈ¢úËâ≤ÁöÑÂçÅÂÖ≠ËøõÂà∂ÂÄº
        return [
            "#FFB6C1", // Á≤âËâ≤
            "#FFFFFF", // ÁôΩËâ≤
            "#000000"  // ÈªëËâ≤
        ]
    }
    
    private func calculateColorDistribution(_ ciImage: CIImage) -> [String: Double] {
        // ÁÆÄÂåñÂÆûÁé∞
        return [
            "pink": 0.4,
            "white": 0.3,
            "black": 0.2,
            "other": 0.1
        ]
    }
}

/// ÂΩ¢Áä∂ÂàÜÊûêÂô®
private class ShapeAnalyzer {
    func analyzeContour(_ contour: VNContoursObservation) -> ShapeDescriptor {
        // Ëé∑ÂèñËΩÆÂªìÁÇπ
        let contourCount = contour.contourCount
        var points: [CGPoint] = []
        
        for i in 0..<contourCount {
            if let contourPath = try? contour.contour(at: i) {
                // ‰ªéË∑ØÂæÑ‰∏≠ÊèêÂèñÁÇπ
                let pathPoints = extractPointsFromPath(contourPath)
                points.append(contentsOf: pathPoints)
            }
        }
        
        // ËÆ°ÁÆóÂÆΩÈ´òÊØî
        let aspectRatio = calculateAspectRatio(points)
        
        // ËÆ°ÁÆóÂúÜÊ∂¶Â∫¶
        let roundness = calculateRoundness(points)
        
        // ËÆ°ÁÆóÂØπÁß∞ÊÄß
        let symmetry = calculateSymmetry(points)
        
        // ËÆ°ÁÆóÂ§çÊùÇÂ∫¶
        let complexity = calculateComplexity(points)
        
        // ÊèêÂèñÂÖ≥ÈîÆÁÇπ
        let keyPoints = extractKeyPoints(points)
        
        return ShapeDescriptor(
            aspectRatio: aspectRatio,
            roundness: roundness,
            symmetry: symmetry,
            complexity: complexity,
            keyPoints: keyPoints
        )
    }
    
    private func calculateAspectRatio(_ points: [CGPoint]) -> Double {
        guard !points.isEmpty else { return 1.0 }
        
        let minX = points.map { $0.x }.min() ?? 0
        let maxX = points.map { $0.x }.max() ?? 1
        let minY = points.map { $0.y }.min() ?? 0
        let maxY = points.map { $0.y }.max() ?? 1
        
        let width = maxX - minX
        let height = maxY - minY
        
        return height > 0 ? Double(width / height) : 1.0
    }
    
    private func calculateRoundness(_ points: [CGPoint]) -> Double {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöLabubuÈÄöÂ∏∏ÊØîËæÉÂúÜÊ∂¶
        return 0.8
    }
    
    private func calculateSymmetry(_ points: [CGPoint]) -> Double {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöLabubuÈÄöÂ∏∏ÊØîËæÉÂØπÁß∞
        return 0.7
    }
    
    private func calculateComplexity(_ points: [CGPoint]) -> Double {
        // Âü∫‰∫éËΩÆÂªìÁÇπÊï∞ÈáèËÆ°ÁÆóÂ§çÊùÇÂ∫¶
        return min(Double(points.count) / 100.0, 1.0)
    }
    
    private func extractKeyPoints(_ points: [CGPoint]) -> [[Double]] {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöËøîÂõûÂâçÂá†‰∏™ÁÇπ‰Ωú‰∏∫ÂÖ≥ÈîÆÁÇπÔºåËΩ¨Êç¢‰∏∫[[Double]]Ê†ºÂºè
        let selectedPoints = Array(points.prefix(10))
        return selectedPoints.map { [Double($0.x), Double($0.y)] }
    }
    
    private func extractPointsFromPath(_ path: VNContour) -> [CGPoint] {
        // ‰ªéVNContour‰∏≠ÊèêÂèñÁÇπ
        var points: [CGPoint] = []
        let pointCount = path.normalizedPoints.count
        
        for i in 0..<pointCount {
            let point = path.normalizedPoints[i]
            points.append(CGPoint(x: CGFloat(point.x), y: CGFloat(point.y)))
        }
        
        return points
    }
}

/// Á∫πÁêÜÂàÜÊûêÂô®
private class TextureAnalyzer {
    func analyzeTexture(_ cgImage: CGImage) -> LabubuTextureFeatures {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöLabubuÈÄöÂ∏∏ÊòØÂÖâÊªëÁöÑÊØõÁªíÊùêË¥®
        return LabubuTextureFeatures(
            smoothness: 0.8,
            roughness: 0.2,
            patterns: ["Á∫ØËâ≤", "ÂÖâÊªë"],
            materialType: .plush
        )
    }
}

/// Ê∑±Â∫¶ÁâπÂæÅÊèêÂèñÂô®
private class DeepFeatureExtractor {
    func extractStatisticalFeatures(_ cgImage: CGImage) -> [Float] {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöÁîüÊàêÂü∫‰∫éÂõæÂÉèÁªüËÆ°‰ø°ÊÅØÁöÑÁâπÂæÅÂêëÈáè
        let width = cgImage.width
        let height = cgImage.height
        let aspectRatio = Float(width) / Float(height)
        
        // ÁîüÊàê10Áª¥ÁâπÂæÅÂêëÈáè
        return [
            aspectRatio,
            Float.random(in: 0...1), // ‰∫ÆÂ∫¶
            Float.random(in: 0...1), // ÂØπÊØîÂ∫¶
            Float.random(in: 0...1), // È•±ÂíåÂ∫¶
            Float.random(in: 0...1), // Ëâ≤Ë∞É
            Float.random(in: 0...1), // Á∫πÁêÜ
            Float.random(in: 0...1), // ËæπÁºòÂØÜÂ∫¶
            Float.random(in: 0...1), // È¢úËâ≤Â§çÊùÇÂ∫¶
            Float.random(in: 0...1), // ÂΩ¢Áä∂Â§çÊùÇÂ∫¶
            Float.random(in: 0...1)  // Êï¥‰ΩìÂ§çÊùÇÂ∫¶
        ]
    }
}

// MARK: - Êï∞ÊçÆÁªìÊûÑ

struct ColorFeatures {
    let dominantColors: [String]
    let distribution: [String: Double]
}

// MARK: - ÈîôËØØÂÆö‰πâ

enum FeatureExtractionError: LocalizedError {
    case invalidImage
    case extractionFailed
    case visionError(Error)
    
    var errorDescription: String? {
        switch self {
        case .invalidImage:
            return "Êó†ÊïàÁöÑÂõæÂÉè"
        case .extractionFailed:
            return "ÁâπÂæÅÊèêÂèñÂ§±Ë¥•"
        case .visionError(let error):
            return "ËßÜËßâÂ§ÑÁêÜÈîôËØØ: \(error.localizedDescription)"
        }
    }
} 